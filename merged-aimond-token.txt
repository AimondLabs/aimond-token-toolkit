
// ── ./README.md ──────────────────────────────────────────────
# Aimond Token Project

An end-to-end solution for the Aimond ecosystem token (AMD), including:

- **ERC20 Token**: `AimondToken` (AMD) — fixed supply token for the Aimond ecosystem.
- **Vesting Contracts**: investor, founder, and employee vesting schedules built on `BaseVestingToken`.
- **Airdrop Mechanism**: on-chain Merkle tree–based distributions via `Airdrop.sol`.
- **Backend Distribution API**: Merkle root management and token allocation backend (see ERD).
- **Gnosis Safe Integration**: secure multisig administration for vesting via Gnosis Safe.

## Table of Contents

- [Aimond Token Project](#aimond-token-project)
  - [Table of Contents](#table-of-contents)
  - [Architecture Overview](#architecture-overview)
  - [Smart Contracts](#smart-contracts)
  - [Database Schema (ERD)](#database-schema-erd)
  - [Documentation](#documentation)
  - [Prerequisites](#prerequisites)
    - [Environment Variables](#environment-variables)
  - [Installation](#installation)
  - [Testing](#testing)
  - [Deployment](#deployment)
  - [Gnosis Safe Integration](#gnosis-safe-integration)
  - [References](#references)

## Architecture Overview

This repository contains:

- Smart contracts for token issuance, vesting schedules, and airdrops.
- A backend schema for generating and tracking Merkle roots and token allocations.
- Helper scripts for deployment and contract interaction via Hardhat.

## Smart Contracts
**Note:** The legacy `contracts/Aimond.sol` file has been removed; its functionality has been consolidated into `AimondToken.sol`.

| Contract                      | Description                                                               |
| ----------------------------- | ------------------------------------------------------------------------- |
| `AimondToken.sol`             | ERC20 token (AMD) with a fixed total supply (88 billion tokens).           |
| `BaseVestingToken.sol`        | Abstract base contract for time-based vesting logic.                      |
| `InvestorVestingToken.sol`    | Vesting logic for investors (10‑month vesting with a 360‑day cliff).       |
| `FounderVestingToken.sol`     | Vesting logic for founders (10‑month vesting with a 660‑day cliff).        |
| `EmployeeVestingToken.sol`    | Vesting logic for employees (one-time cliff of 960 days).                 |


## Database Schema (ERD)

The Merkle root and token allocation database schema is defined in [ERD.md](docs/ERD.md).

## Documentation

- **Token Minting Schedule:** [Aimond AIM Token Minting_250703_V9.pdf](docs/Aimond%20AIM%20Token%20Minting_250703_V9.pdf)
- **Gnosis Safe Integration Guide:** [GNOSIS_SAFE_GUIDE.md](docs/GNOSIS_SAFE_GUIDE.md)

## Prerequisites

- Node.js (>= 20.x)
- Yarn or npm
- Hardhat
- A `.env` file (see below)

### Environment Variables

Create a `.env` file in the project root with the following variables:

```dotenv
BSC_URL=<your BSC mainnet RPC URL>
BSC_TESTNET_URL=<your BSC testnet RPC URL>
ADMIN_KEY=<deployer private key>
USER_KEY=<secondary key for tests/deployments>
ADMIN_ADDRESS=<deployer address>
USER_ADDRESS=<secondary address>
RECIPIENT_ADDRESS=<recipient address for transfers>
AIMOND_ADDRESS=<deployed AimondToken address>
```

## Installation

```bash
yarn install
```

## Testing

Run the full test suite:

```bash
yarn test
```

Or run a specific suite:

```bash
yarn test:inv   # InvestorVesting tests
yarn test:fnd   # FounderVesting tests
yarn test:emp   # EmployeeVesting tests
```

## Deployment

Compile contracts:

```bash
yarn build
```

Start a local Hardhat node:

```bash
yarn localnode
```

Deploy to local network:

```bash
yarn deploy:aim:localnet
```

Deploy to BSC mainnet or testnet:

```bash
yarn deploy:aim:bsc
yarn deploy:aim:bscTestnet
```

Other deployment and transfer scripts for Jaymond token are also available in `package.json`.

## Gnosis Safe Integration

For instructions on administering vesting contracts via Gnosis Safe multisig, see [Gnosis Safe Guide](docs/GNOSIS_SAFE_GUIDE.md).

## References

- [Deploying Smart Contract to BSC Testnet with Hardhat](https://medium.com/@melihgunduz/deploying-smart-contract-to-bsc-testnet-with-hardhat-aa7b046eea1d)

// ── ./contracts/AimondToken.sol ──────────────────────────────────────────────
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title AimondToken
 * @author AimondLabs
 * @notice This is the main ERC20 token for the Aimond ecosystem.
 * It has a fixed total supply and is owned by an initial owner.
 */
contract AimondToken is ERC20, Ownable {
    /**
     * @dev The total supply of AimondToken (AMD) tokens, fixed at 88 billion.
     */
    uint256 public constant TOTAL_SUPPLY = 88_000_000_000 * (10 ** 18);

    /**
     * @dev Sets up the contract, minting the total supply to the initial owner.
     * @param initialOwner The address that will receive the total supply and own the contract.
     */
    constructor(
        address initialOwner
    ) ERC20("Aimond Token", "AMD") Ownable(initialOwner) {
        _mint(initialOwner, TOTAL_SUPPLY);
    }
}

// ── ./contracts/BaseVestingToken.sol ──────────────────────────────────────────────
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";

/**
 * @title BaseVestingToken
 * @author AimondLabs
 * @notice An abstract base contract for vesting tokens. It combines ERC20 functionality
 * with vesting logic for a separate token (AMD).
 * @dev This contract manages the vesting schedules and release of a specified ERC20 token (amdToken).
 * It uses AccessControl for managing distributor roles.
 */
abstract contract BaseVestingToken is
    ERC20,
    Ownable,
    ReentrancyGuard,
    AccessControlEnumerable
{
    using SafeERC20 for IERC20Metadata;

    /**
     * @dev Represents a vesting schedule for a beneficiary.
     * @param totalAmount The total amount of tokens to be vested.
     * @param totalVestingDuration The total duration of the vesting period in seconds, after the cliff.
     * @param cliffDuration The duration in seconds before vesting starts.
     * @param releaseDuration The duration in second after cliff ends.
     * @param installmentCount The number of installments in which the tokens are released.
     * @param releasedAmount The amount of tokens already released.
     */
    struct VestingSchedule {
        uint256 totalAmount;
        uint256 totalVestingDuration;
        uint256 cliffDuration;
        uint256 releaseDuration;
        uint256 installmentCount;
        uint256 releasedAmount;
    }

    /**
     * @dev Mapping from a beneficiary address to their vesting schedule.
     */
    mapping(address => VestingSchedule) public vestingSchedules;

    /**
     * @dev Emitted when a new distributor is added.
     * @param account The address of the new distributor.
     */
    event DistributorAdded(address indexed account);

    /**
     * @dev Emitted when a distributor is removed.
     * @param account The address of the removed distributor.
     */
    event DistributorRemoved(address indexed account);

    /**
     * @dev The ERC20 token that will be vested and released.
     */
    IERC20Metadata public amdToken;

    /**
     * @dev The global start time for all vesting schedules, as a Unix timestamp.
     */
    uint256 public globalStartTime;

    /**
     * @dev Emitted when a new vesting schedule is created.
     * @param beneficiary The address of the beneficiary.
     * @param totalVestingDuration The total duration of the vesting period in seconds, after the cliff.
     * @param cliffDuration The duration in seconds before vesting starts.
     * @param releaseDuration The duration in second after cliff ends.
     * @param installmentCount The number of installments in which the tokens are released.
     * @param totalAmount The total amount of tokens to be vested.
     */
    event VestingScheduleCreated(
        address indexed beneficiary,
        uint256 totalVestingDuration,
        uint256 cliffDuration,
        uint256 releaseDuration,
        uint256 installmentCount,
        uint256 totalAmount
    );

    /**
     * @dev Emitted when tokens are released to a beneficiary.
     * @param beneficiary The address of the beneficiary.
     * @param amount The amount of tokens released.
     */
    event TokensReleased(address indexed beneficiary, uint256 amount);

    /**
     * @dev Emitted when the global start time is set.
     * @param startTime The new global start time.
     */
    event GlobalStartTimeSet(uint256 startTime);

    /**
     * @dev The maximum number of beneficiaries that can be released in a single batch transaction.
     */
    uint256 public constant MAX_BATCH = 100;

    /**
     * @dev Role for addresses that can distribute tokens.
     */
    bytes32 public constant DISTRIBUTOR_ROLE = keccak256("DISTRIBUTOR_ROLE");

    /**
     * @dev Role for addresses that can manage distributors.
     */
    bytes32 public constant DISTRIBUTOR_MANAGER_ROLE =
        keccak256("DISTRIBUTOR_MANAGER_ROLE");

    /**
     * @dev Sets up the contract with initial parameters.
     * @param name The name of the vesting token.
     * @param symbol The symbol of the vesting token.
     * @param initialOwner The initial owner of the contract.
     * @param initialDistributorManager The initial distributor manager.
     * @param amdTokenAddress The address of the AMD token.
     * @param initialSupply The initial supply of the vesting token.
     */
    constructor(
        string memory name,
        string memory symbol,
        address initialOwner,
        address initialDistributorManager,
        address amdTokenAddress,
        uint256 initialSupply
    ) ERC20(name, symbol) Ownable(initialOwner) {
        _grantRole(DEFAULT_ADMIN_ROLE, initialOwner);
        _grantRole(DISTRIBUTOR_ROLE, initialOwner);
        _grantRole(DISTRIBUTOR_ROLE, initialDistributorManager);
        _grantRole(DISTRIBUTOR_MANAGER_ROLE, initialDistributorManager);
        _grantRole(DISTRIBUTOR_MANAGER_ROLE, initialOwner);

        require(amdTokenAddress != address(0), "Invalid AMD token address");
        _mint(initialOwner, initialSupply);
        amdToken = IERC20Metadata(amdTokenAddress);
        require(amdToken.decimals() == decimals(), "Token decimals must match");
    }

    /**
     * @dev Overrides the default transfer function to restrict it to distributors.
     * @param to The address to transfer to.
     * @param amount The amount to transfer.
     * @return A boolean indicating whether the operation succeeded.
     */
    function transfer(
        address to,
        uint256 amount
    ) public virtual override onlyRole(DISTRIBUTOR_ROLE) returns (bool) {
        return super.transfer(to, amount);
    }

    /**
     * @dev Overrides the default transferFrom function to restrict it to distributors.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param amount The amount to transfer.
     * @return A boolean indicating whether the operation succeeded.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override onlyRole(DISTRIBUTOR_ROLE) returns (bool) {
        return super.transferFrom(from, to, amount);
    }

    /**
     * @dev Adds a new distributor manager.
     * @param account The address of the new distributor manager.
     */
    function addDistributorManager(
        address account
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(DISTRIBUTOR_MANAGER_ROLE, account);
    }

    /**
     * @dev Removes a distributor manager.
     * @param account The address of the distributor manager to remove.
     */
    function removeDistributorManager(
        address account
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        _revokeRole(DISTRIBUTOR_MANAGER_ROLE, account);
    }

    /**
     * @dev Adds a new distributor.
     * @param account The address of the new distributor.
     */
    function addDistributor(
        address account
    ) public onlyRole(DISTRIBUTOR_MANAGER_ROLE) {
        require(
            !hasRole(DISTRIBUTOR_ROLE, account),
            "Account already has DISTRIBUTOR_ROLE"
        );

        _grantRole(DISTRIBUTOR_ROLE, account);
        emit DistributorAdded(account);
    }

    /**
     * @dev Removes a distributor.
     * @param account The address of the distributor to remove.
     */
    function removeDistributor(
        address account
    ) public onlyRole(DISTRIBUTOR_MANAGER_ROLE) {
        require(
            hasRole(DISTRIBUTOR_ROLE, account),
            "Account does not have DISTRIBUTOR_ROLE"
        );

        _revokeRole(DISTRIBUTOR_ROLE, account);
        emit DistributorRemoved(account);
    }

    /**
     * @dev Internal function to create a vesting schedule for a beneficiary.
     * @param beneficiary The address of the beneficiary.
     * @param cliffDurationInDays The cliff duration in days.
     * @param vestingDurationInDays The vesting duration in days.
     * @param installmentCount The number of installments.
     * @param _totalAmount The total amount of tokens to be vested.
     */
    function _createVestingSchedule(
        address beneficiary,
        uint256 cliffDurationInDays,
        uint256 vestingDurationInDays,
        uint256 installmentCount,
        uint256 _totalAmount
    ) internal {
        require(
            vestingSchedules[beneficiary].totalAmount == 0,
            "Vesting schedule already exists"
        );
        require(_totalAmount > 0, "Total amount must be greater than 0");
        require(installmentCount > 0, "Installment count must be > 0");
        require(
            vestingDurationInDays >= cliffDurationInDays,
            "Vesting duration must be greater than or equal to cliff duration"
        );
        // Transfer tokens from the owner (msg.sender) to the beneficiary.
        transfer(beneficiary, _totalAmount);

        uint256 cliffDuration = cliffDurationInDays * 86400;
        uint256 totalVestingDuration = vestingDurationInDays * 86400;
        uint256 releaseDuration = totalVestingDuration - cliffDuration;

        vestingSchedules[beneficiary] = VestingSchedule({
            totalAmount: _totalAmount,
            totalVestingDuration: totalVestingDuration,
            cliffDuration: cliffDuration,
            releaseDuration: releaseDuration,
            installmentCount: installmentCount,
            releasedAmount: 0
        });
        emit VestingScheduleCreated(
            beneficiary,
            totalVestingDuration,
            cliffDuration,
            releaseDuration,
            installmentCount,
            _totalAmount
        );
    }

    /**
     * @dev Internal function for a beneficiary to claim their vested tokens.
     */
    function _claim() internal {
        _releaseVestedTokens(msg.sender);
    }

    /**
     * @dev Releases vested tokens to a specific beneficiary. Can only be called by the owner.
     * @param beneficiary The address of the beneficiary.
     */
    function releaseTo(address beneficiary) public nonReentrant onlyOwner {
        _releaseVestedTokens(beneficiary);
    }

    /**
     * @dev Releases vested tokens to a batch of beneficiaries. Can only be called by the owner.
     * @param beneficiaries An array of beneficiary addresses.
     */
    function releaseToBatch(
        address[] calldata beneficiaries
    ) public nonReentrant onlyOwner {
        require(beneficiaries.length <= MAX_BATCH, "Batch size exceeds limit");
        require(globalStartTime > 0, "Global start time not set");
        for (uint256 i = 0; i < beneficiaries.length; i++) {
            _releaseVestedTokens(beneficiaries[i]);
        }
    }

    /**
     * @dev Internal function to release vested tokens to a beneficiary.
     * @param beneficiary The address of the beneficiary.
     */
    function _releaseVestedTokens(address beneficiary) internal {
        require(globalStartTime > 0, "Global start time not set");
        uint256 totalReleasableAmount = getCurrentlyReleasableAmount(
            beneficiary
        );

        if (totalReleasableAmount > 0) {
            VestingSchedule storage schedule = vestingSchedules[beneficiary];
            schedule.releasedAmount += totalReleasableAmount;
            amdToken.safeTransfer(beneficiary, totalReleasableAmount);
            emit TokensReleased(beneficiary, totalReleasableAmount);
        }
    }

    /**
     * @dev Sets the global start time for all vesting schedules. Can only be called once.
     * @param newStartTime The new global start time as a Unix timestamp.
     */
    function setGlobalStartTime(uint256 newStartTime) public onlyOwner {
        require(globalStartTime == 0, "Global start time already set");
        require(newStartTime > 0, "Invalid start time");
        globalStartTime = (newStartTime / 86400) * 86400; // Floor to the nearest day
        emit GlobalStartTimeSet(globalStartTime);
    }

    /**
     * @dev Calculates the amount of tokens that are currently releasable for a beneficiary.
     * @param beneficiary The address of the beneficiary.
     * @return The amount of releasable tokens.
     */
    function getCurrentlyReleasableAmount(
        address beneficiary
    ) public view returns (uint256) {
        VestingSchedule storage schedule = vestingSchedules[beneficiary];
        if (
            globalStartTime == 0 ||
            schedule.totalAmount == 0 ||
            schedule.totalAmount == schedule.releasedAmount
        ) {
            return 0;
        }

        // If current time is before the cliff ends, no tokens are vested
        if (block.timestamp < globalStartTime + schedule.cliffDuration) {
            return 0;
        }

        // Explicitly handle single-installment schedules (one-time release after cliff)
        if (schedule.installmentCount == 1) {
            return schedule.totalAmount - schedule.releasedAmount;
        }

        uint256 installmentDuration = schedule.releaseDuration /
            schedule.installmentCount;

        uint256 timeSinceCliffEnd = block.timestamp -
            (globalStartTime + schedule.cliffDuration);
        uint256 vestedInstallments = timeSinceCliffEnd /
            installmentDuration +
            1;

        // Cap vested installments at the total count to prevent overshooting due to
        // calculation precision or edge cases.
        if (vestedInstallments > schedule.installmentCount) {
            vestedInstallments = schedule.installmentCount;
        }

        uint256 totalVestedAmount;
        if (vestedInstallments == schedule.installmentCount) {
            totalVestedAmount = schedule.totalAmount;
        } else {
            uint256 vestedProportionNumerator = schedule.totalAmount *
                vestedInstallments;
            totalVestedAmount =
                vestedProportionNumerator /
                schedule.installmentCount;
        }

        return totalVestedAmount - schedule.releasedAmount;
    }
}

// ── ./contracts/EmployeeVestingToken.sol ──────────────────────────────────────────────
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "./BaseVestingToken.sol";

/**
 * @title EmployeeVestingToken
 * @author AimondLabs
 * @notice A specific vesting token for employees, inheriting from BaseVestingToken.
 * @dev This contract defines a fixed vesting schedule for employees.
 */
contract EmployeeVestingToken is BaseVestingToken {
    /**
     * @dev The cliff period for employee vesting in days.
     */
    uint256 private constant EMPLOYEE_CLIFF_DAYS = 960;

    /**
     * @dev The vesting period for employee vesting in days.
     */
    uint256 private constant EMPLOYEE_VESTING_DAYS = EMPLOYEE_CLIFF_DAYS;

    /**
     * @dev The number of installments for employee vesting.
     */
    uint256 private constant EMPLOYEE_INSTALLMENT_COUNT = 1;

    /**
     * @dev The total supply of EmployeeVestingToken tokens, fixed at 5.2 billion.
     */
    uint256 private constant TOTAL_SUPPLY = 5_200_000_000 * 10**18;

    /**
     * @dev Sets up the contract with initial parameters for employee vesting.
     * @param initialOwner The initial owner of the contract.
     * @param initialDistributorManager The initial distributor manager.
     * @param amdTokenAddress The address of the AMD token.
     */
    constructor(
        address initialOwner,
        address initialDistributorManager,
        address amdTokenAddress
    )
        BaseVestingToken(
            "EmployeeVestingToken",
            "AIME",
            initialOwner,
            initialDistributorManager,
            amdTokenAddress,
            TOTAL_SUPPLY
        )
    {}

    /**
     * @notice Creates a vesting schedule for an employee.
     * @dev Can only be called by the owner.
     * @param beneficiary The address of the employee.
     * @param totalAmount The total amount of tokens to be vested.
     */
    function createVesting(
        address beneficiary,
        uint256 totalAmount
    ) public onlyOwner {
        _createVestingSchedule(
            beneficiary,
            EMPLOYEE_CLIFF_DAYS,
            EMPLOYEE_VESTING_DAYS,
            EMPLOYEE_INSTALLMENT_COUNT,
            totalAmount
        );
    }
}

// ── ./contracts/FounderVestingToken.sol ──────────────────────────────────────────────
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "./BaseVestingToken.sol";

/**
 * @title FounderVestingToken
 * @author AimondLabs
 * @notice A specific vesting token for founders, inheriting from BaseVestingToken.
 * @dev This contract defines a fixed vesting schedule for founders.
 */
contract FounderVestingToken is BaseVestingToken {
    /**
     * @dev The cliff period for founder vesting in days.
     */
    uint256 private constant FOUNDER_CLIFF_DAYS = 660;

    /**
     * @dev The vesting period for founder vesting in days.
     */
    uint256 private constant FOUNDER_VESTING_DAYS = FOUNDER_CLIFF_DAYS + 300;

    /**
     * @dev The number of installments for founder vesting.
     */
    uint256 private constant FOUNDER_INSTALLMENT_COUNT = 10;

    /**
     * @dev The total supply of FounderVestingToken tokens, fixed at 20 billion.
     */
    uint256 private constant TOTAL_SUPPLY = 20_000_000_000 * 10**18;

    /**
     * @dev Sets up the contract with initial parameters for founder vesting.
     * @param initialOwner The initial owner of the contract.
     * @param initialDistributorManager The initial distributor manager.
     * @param amdTokenAddress The address of the AMD token.
     */
    constructor(
        address initialOwner,
        address initialDistributorManager,
        address amdTokenAddress
    )
        BaseVestingToken(
            "FounderVestingToken",
            "AIMF",
            initialOwner,
            initialDistributorManager,
            amdTokenAddress,
            TOTAL_SUPPLY
        )
    {}

    /**
     * @notice Creates a vesting schedule for a founder.
     * @dev Can only be called by the owner.
     * @param beneficiary The address of the founder.
     * @param totalAmount The total amount of tokens to be vested.
     */
    function createVesting(
        address beneficiary,
        uint256 totalAmount
    ) public onlyOwner {
        _createVestingSchedule(
            beneficiary,
            FOUNDER_CLIFF_DAYS,
            FOUNDER_VESTING_DAYS,
            FOUNDER_INSTALLMENT_COUNT,
            totalAmount
        );
    }
}

// ── ./contracts/InvestorVestingToken.sol ──────────────────────────────────────────────
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "./BaseVestingToken.sol";

/**
 * @title InvestorVestingToken
 * @author AimondLabs
 * @notice A specific vesting token for investors, inheriting from BaseVestingToken.
 * @dev This contract defines a fixed vesting schedule for investors and allows them to claim their vested tokens.
 */
contract InvestorVestingToken is BaseVestingToken {
    /**
     * @dev The cliff period for investor vesting in days.
     */
    uint256 private constant INVESTOR_CLIFF_DAYS = 360;

    /**
     * @dev The vesting period for investor vesting in days.
     */
    uint256 private constant INVESTOR_VESTING_DAYS = INVESTOR_CLIFF_DAYS + 300;

    /**
     * @dev The number of installments for investor vesting.
     */
    uint256 private constant INVESTOR_INSTALLMENT_COUNT = 10;

    /**
     * @dev The total supply of InvestorVestingToken tokens, fixed at 24 billion.
     */
    uint256 private constant TOTAL_SUPPLY = 24_000_000_000 * 10**18;

    /**
     * @dev Sets up the contract with initial parameters for investor vesting.
     * @param initialOwner The initial owner of the contract.
     * @param initialDistributorManager The initial distributor manager.
     * @param amdTokenAddress The address of the AMD token.
     */
    constructor(
        address initialOwner,
        address initialDistributorManager,
        address amdTokenAddress
    )
        BaseVestingToken(
            "InvestorVestingToken",
            "AIMI",
            initialOwner,
            initialDistributorManager,
            amdTokenAddress,
            TOTAL_SUPPLY
        )
    {}

    /**
     * @notice Creates a vesting schedule for an investor.
     * @dev Can only be called by the owner.
     * @param beneficiary The address of the investor.
     * @param totalAmount The total amount of tokens to be vested.
     */
    function createVesting(
        address beneficiary,
        uint256 totalAmount
    ) public onlyOwner {
        _createVestingSchedule(
            beneficiary,
            INVESTOR_CLIFF_DAYS,
            INVESTOR_VESTING_DAYS,
            INVESTOR_INSTALLMENT_COUNT,
            totalAmount
        );
    }

    /**
     * @notice Allows a beneficiary to claim their vested tokens.
     */
    function claim() public nonReentrant {
        _claim();
    }
}

// ── ./contracts/LoyaltyPoint.sol ──────────────────────────────────────────────
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";

contract LoyaltyPoint is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    IERC20 public immutable amdToken;
    bytes32 public merkleRoot;

    mapping(address => uint256) public claimed; // total already given (on-chain truth)

    event RootUpdated(bytes32 newRoot);
    event Claimed(address indexed user, uint256 amount);

    constructor(IERC20 _token, bytes32 _root, address _admin) {
        amdToken = _token;
        merkleRoot = _root;
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // msg.sender is the owner (multisig)
        _grantRole(ADMIN_ROLE, _admin);
        _grantRole(ADMIN_ROLE, msg.sender); // Grant admin role to the owner as well
    }

    function updateRoot(bytes32 _root) external onlyRole(DEFAULT_ADMIN_ROLE) {
        merkleRoot = _root;
        emit RootUpdated(_root);
    }

    // leaf is keccak256(abi.encodePacked(user, cumulativeAmount))
    function claimForUser(
        address user,
        uint256 cumulativeAmount,
        bytes32[] calldata proof
    ) external onlyRole(ADMIN_ROLE) {
        bytes32 leaf = keccak256(abi.encodePacked(user, cumulativeAmount));
        require(
            MerkleProof.verifyCalldata(proof, merkleRoot, leaf),
            "bad proof"
        );

        uint256 already = claimed[user];
        require(cumulativeAmount > already, "nothing to claim");
        uint256 toSend = cumulativeAmount - already;

        claimed[user] = cumulativeAmount;
        require(amdToken.transfer(user, toSend), "transfer failed");
        emit Claimed(user, toSend);
    }
}

// ── ./contracts/mocks/MockVestingToken.sol ──────────────────────────────────────────────
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "../BaseVestingToken.sol";

/**
 * @title MockVestingToken
 * @author AimondLabs
 * @notice A mock vesting token for testing purposes.
 * @dev This contract inherits from BaseVestingToken and provides a simplified vesting schedule creation for testing.
 */
contract MockVestingToken is BaseVestingToken {
    uint256 public immutable cliffDurationInDays;
    uint256 public immutable vestingDurationInDays;
    uint256 public immutable installmentCount;

    /**
     * @dev Sets up the contract with initial parameters for the mock vesting token.
     * @param initialOwner The initial owner of the contract.
     * @param initialDistributorManager The initial distributor manager.
     * @param amdTokenAddress The address of the AMD token.
     * @param _cliffDurationInDays The cliff duration in days.
     * @param _vestingDurationInDays The total vesting duration in days.
     * @param _installmentCount The number of installments.
     */
    constructor(
        address initialOwner,
        address initialDistributorManager,
        address amdTokenAddress,
        uint256 _cliffDurationInDays,
        uint256 _vestingDurationInDays,
        uint256 _installmentCount
    )
        BaseVestingToken(
            "MockVestingToken",
            "MVST",
            initialOwner,
            initialDistributorManager,
            amdTokenAddress,
            1000000000 * (10 ** 18)
        )
    {
        cliffDurationInDays = _cliffDurationInDays;
        vestingDurationInDays = _vestingDurationInDays;
        installmentCount = _installmentCount;
    }

    /**
     * @notice Creates a vesting schedule for a beneficiary with the mock schedule.
     * @dev Can only be called by an address with the DISTRIBUTOR_ROLE.
     * @param beneficiary The address of the beneficiary.
     * @param totalAmount The total amount of tokens to be vested.
     */
    function createVestingSchedule(
        address beneficiary,
        uint256 totalAmount
    ) public onlyRole(DISTRIBUTOR_ROLE) {
        

        _createVestingSchedule(
            beneficiary,
            cliffDurationInDays,
            vestingDurationInDays,
            installmentCount,
            totalAmount
        );
    }

    /**
     * @notice Allows a beneficiary to claim their vested tokens.
     */
    function claim() public nonReentrant {
        _releaseVestedTokens(msg.sender);
    }
}
// ── ./docs/ERD.md ──────────────────────────────────────────────
# Entity-Relationship Diagram (ERD) for Token Distribution Backend

This ERD outlines the core database tables and their relationships for managing token allocations and claims using a Merkle tree-based system.

## Table Descriptions:

### `users`
Stores general user profile information and their associated blockchain wallet addresses. This table is the source of truth for user eligibility and continuously updated metrics.

| Column Name      | Data Type      | Description                                                              | Notes                                     |
| :--------------- | :------------- | :----------------------------------------------------------------------- | :---------------------------------------- |
| `id`             | `BIGINT`       | Primary Key, Auto-incrementing                                           | Internal user ID                          |
| `wallet_address` | `VARCHAR(42)`  | The user's Ethereum wallet address (e.g., `0x...`)                       | **Crucial for on-chain interaction.** Unique, Indexed. |
| `email`          | `VARCHAR(255)` | User's email address                                                     | Unique, Indexed                           |
| `username`       | `VARCHAR(255)` | User's chosen username                                                   | Unique, Indexed (optional)                |
| `created_at`     | `TIMESTAMP`    | Timestamp when the user record was created                               |                                           |
| `updated_at`     | `TIMESTAMP`    | Timestamp when the user record was last updated                          |                                           |
| `is_new_member`  | `BOOLEAN`      | Flag indicating if they are a "new member" for token purposes            | Used by backend logic for "New Member Token" eligibility. |
| `total_cumulative_spending` | `DECIMAL`      | Accumulated lifetime spending in USD (or equivalent)                     | This is a derived, cumulative sum from `user_spending_events`. |
| ...              | ...            | Other relevant user profile data (e.g., referral code, last login, etc.) |                                           |

### `user_spending_events`
Logs every individual spending action by a user. This granular data allows for flexible calculation of spending for any arbitrary period.

| Column Name      | Data Type      | Description                                                              | Notes                                     |
| :--------------- | :------------- | :----------------------------------------------------------------------- | :---------------------------------------- |
| `id`             | `BIGINT`       | Primary Key, Auto-incrementing                                           | Internal ID for the spending event        |
| `user_id`        | `BIGINT`       | Foreign Key to `users.id`. Links the spending event to a specific user.  | Indexed.                                  |
| `amount_spent`   | `DECIMAL`      | The amount spent in this specific event.                                 |                                           |
| `currency`       | `VARCHAR(10)`  | The currency of the spending (e.g., 'USD', 'KRW').                     |                                           |
| `timestamp`      | `TIMESTAMP`    | The exact time when the spending occurred.                               | Indexed.                                  |
| `description`    | `TEXT`         | Optional: More details about the spending event.                         | Nullable.                                 |

### `merkle_roots`
Tracks each Merkle root that has been generated and committed to a specific smart contract. This table serves as a historical record of distribution periods for different token programs.

| Column Name         | Data Type      | Description                                                              | Notes                                     |
| :------------------ | :------------- | :----------------------------------------------------------------------- | :---------------------------------------- |
| `id`                | `BIGINT`       | Primary Key, Auto-incrementing                                           |
| `root_hash`         | `VARCHAR(66)`  | The actual Merkle root hash (e.g., `0x...`)                              | **Unique, Indexed.** This is what goes on-chain. |
| `contract_address`  | `VARCHAR(42)`  | The address of the smart contract where this root was committed          | e.g., `NewMemberToken` or `PaidPoint` contract |
| `distribution_type` | `VARCHAR(50)`  | Categorizes the type of distribution (e.g., 'new_member_token', 'paid_point') | **Unique constraint with `root_hash`**. Useful for managing multiple programs. |
| `period_start_date` | `TIMESTAMP`    | The start date of the period for which this root's data was collected    |                                           |
| `period_end_date`   | `TIMESTAMP`    | The end date of the period for which this root's data was collected      |                                           |
| `is_active`         | `BOOLEAN`      | Flag indicating if this is the currently active root for claiming        | Only one `is_active` per `distribution_type` should be true at a time. |
| `created_at`        | `TIMESTAMP`    | Timestamp when the root was generated and recorded                       |                                           |

### `token_allocations`
Stores the final, aggregated `(wallet_address, amount)` pairs that form the leaves of a specific Merkle tree. These are the entitlements that users can claim for a given period and distribution type.

| Column Name      | Data Type      | Description                                                              | Notes                                     |
| :--------------- | :------------- | :----------------------------------------------------------------------- | :---------------------------------------- |
| `id`             | `BIGINT`       | Primary Key, Auto-incrementing                                           |
| `merkle_root_id` | `BIGINT`       | Foreign Key to `merkle_roots.id`. Links this allocation to a specific Merkle root. | Indexed. |
| `wallet_address` | `VARCHAR(42)`  | The user's wallet address for this specific allocation                   | **Foreign Key to `users.wallet_address`**. Indexed. |
| `amount`         | `VARCHAR(78)`  | The exact token amount allocated to this address (as a string to handle large `uint256` values) | This is the `tokenAmount` in the Merkle leaf. |
| `is_claimed`     | `BOOLEAN`      | Flag indicating if this specific allocation has been claimed             | Default: `FALSE`. Prevents double claims. |
| `claim_tx_hash`  | `VARCHAR(66)`  | The transaction hash of the claim (if claimed)                           | Nullable.                                 |
| `claimed_at`     | `TIMESTAMP`    | Timestamp when this allocation was claimed (if claimed)                  | Nullable.                                 |
| `created_at`     | `TIMESTAMP`    | Timestamp when this allocation record was created                        |                                           |

## Entity-Relationship Diagram:

```
+-----------------------+       +---------------------------+
|         users         |       |  user_spending_events     |
+-----------------------+       +---------------------------+
| id (PK)               |<------| user_id (FK)              |
| wallet_address (U)    |       | amount_spent              |
| email (U)             |       | currency                  |
| username              |       | timestamp                 |
| created_at            |       | description               |
| updated_at            |       +---------------------------+
| is_new_member         |
| total_cumulative_spending |
+-----------------------+
        | 1
        | 
        | M
        V
+-----------------------+
|   token_allocations   |
+-----------------------+
| id (PK)               |
| merkle_root_id (FK)   |
| wallet_address (FK)   |                                  
| amount                |                                  
| is_claimed            |                                  
| claim_tx_hash         |                                  
| claimed_at            |                                  
| created_at            |                                  
+-----------------------+
        | M                                                
        |                                                  
        |                                                  
        +--------------------------------------------------+
                                                          |
                                                          V
                                                      +---------------------+
                                                      |    merkle_roots     |
                                                      +---------------------+
                                                      | id (PK)             |
                                                      | root_hash (U)       |
                                                      | contract_address    |
                                                      | distribution_type (U)|
                                                      | period_start_date   |
                                                      | period_end_date     |
                                                      | is_active           |
                                                      | created_at          |
                                                      +---------------------+
```

### Relationship Explanations:

*   **`users` to `user_spending_events` (One-to-Many):**
    *   One `user` can have many `user_spending_events` records, detailing each instance of their spending.
    *   This relationship is a direct foreign key constraint.

*   **`users` to `token_allocations` (One-to-Many):**
    *   A `user` can have multiple `token_allocations` entries over time, potentially from different `merkle_roots` (e.g., a user might claim new member tokens in one period and paid points in another).
    *   The `wallet_address` in `token_allocations` is a Foreign Key referencing `users.wallet_address`, ensuring that every allocation is tied to a valid user in the `users` table.

*   **`merkle_roots` to `token_allocations` (Many-to-1):**
    *   Many `token_allocations` records (leaves) belong to one `merkle_roots` entry (a single Merkle tree snapshot).
    *   The `merkle_root_id` in `token_allocations` is the Foreign Key linking each allocation back to the specific Merkle root it belongs to.

This updated ERD provides a clear overview of the data structure required to implement a scalable, Merkle tree-based token distribution system, accommodating both one-time and continuous earning scenarios.

// ── ./docs/GNOSIS_SAFE_GUIDE.md ──────────────────────────────────────────────
# Aimond Token


## Integrating AimondVesting with Gnosis Safe

To manage the `AimondVesting` contract's administrative functions (e.g., `createVestingSchedule`) using a Gnosis Safe multisig, follow these steps:

### 1. Deploy Your Gnosis Safe

Ensure you have a Gnosis Safe deployed on the target network. Note down its contract address. This address will be the `owner` of your `AimondVesting` contract.

### 2. Deploy AimondVesting with Gnosis Safe as Owner

When deploying the `AimondVesting` contract, you must set the Gnosis Safe's address as the `owner` in the constructor.

Example (using Hardhat deployment script):

```typescript
// scripts/deploy-aimond-vesting.ts
import { ethers } from "hardhat";

async function main() {
  const AimondTokenAddress = "YOUR_AIMOND_TOKEN_ADDRESS"; // Replace with your deployed AimondToken address
  const GnosisSafeAddress = "YOUR_GNOSIS_SAFE_ADDRESS"; // Replace with your deployed Gnosis Safe address

  const aimondVesting = await ethers.deployContract("AimondVesting", [AimondTokenAddress, GnosisSafeAddress]); // Pass GnosisSafeAddress as owner

  await aimondVesting.waitForDeployment();

  console.log(`AimondVesting deployed to: ${aimondVesting.target}`);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

**Note:** The `AimondVesting` constructor currently takes `tokenAddress` and `msg.sender` (which is the deployer). You will need to modify the `AimondVesting` constructor to accept an `_owner` address parameter, which you will then pass to the `Ownable` constructor.

### 3. Interact with AimondVesting via Gnosis Safe

Once `AimondVesting` is deployed with the Gnosis Safe as its owner, all functions protected by `onlyOwner` (like `createVestingSchedule`) must be called through the Gnosis Safe interface.

1.  **Go to your Gnosis Safe UI:** Access your Gnosis Safe on the appropriate network.
2.  **Navigate to "New Transaction" -> "Contract Interaction":**
    *   **Recipient:** Enter the deployed `AimondVesting` contract address.
    *   **ABI:** Paste the ABI of the `AimondVesting` contract. You can usually find this in your Hardhat `artifacts` directory (e.g., `artifacts/contracts/AimondVesting.sol/AimondVesting.json`).
    *   **Method:** Select the `createVestingSchedule` method (or any other `onlyOwner` function you wish to call).
    *   **Parameters:** Fill in the required parameters for the selected method.
3.  **Propose and Execute Transaction:** Propose the transaction. Once enough signers confirm, the transaction will be executed by the Gnosis Safe.
// ── ./hardhat.config.ts ──────────────────────────────────────────────
import { config as dotEnvConfig } from "dotenv";
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import { Wallet, parseEther } from "ethers";
import { HardhatNetworkAccountUserConfig } from "hardhat/types/config";

dotEnvConfig({ path: process.env.ENV_FILE || ".env" });

function getAccounts() {
  const accounts: HardhatNetworkAccountUserConfig[] = [];
  const defaultBalance = parseEther("2000000").toString();

  const n = 10;
  for (let i = 0; i < n; ++i) {
    accounts.push({
      privateKey: Wallet.createRandom().privateKey,
      balance: defaultBalance,
    });
  }
  accounts[0].privateKey = process.env.ADMIN_KEY || "";
  accounts[1].privateKey = process.env.USER_KEY || "";

  return accounts;
}

const config: HardhatUserConfig = {
  solidity: {
    compilers: [
      {
        version: "0.8.24",
        settings: {
          // turn optimizer on/off here:
          optimizer: {
            enabled: false,   // ← set to `false` to disable
            runs: 200        // ← match this to BscScan “runs” setting
          }
        }
      }
    ]
  },
  defaultNetwork: "hardhat",
  networks: {
    hardhat: {
      accounts: getAccounts(),
    },
    localnet: {
      url: "http://127.0.0.1:8545",
      chainId: 12301, // 31337 is the default chain ID for Hardhat local network
      accounts: [
        process.env.ADMIN_KEY || "",
        process.env.USER_KEY || "",
      ],
    },
    bsc: {
      url: "https://bsc-dataseed1.binance.org/",
      chainId: 56,
      accounts: [
        process.env.ADMIN_KEY || "",
        process.env.USER_KEY || "",
      ],
    },
    bscTestnet: {
      url: "https://data-seed-prebsc-1-s1.binance.org:8545",
      chainId: 97,
      accounts: [
        process.env.ADMIN_KEY || "",
        process.env.USER_KEY || "",
      ],
    }
  },
  etherscan: {
    apiKey: {
      bsc: 'G3CC3P4J717124Y31J9ZMPBH2G4KPY98FT'
    }
  },
  sourcify: {
    enabled: true
  },
  gasReporter: {
    enabled: false,
  }
};

export default config;

// ── ./package.json ──────────────────────────────────────────────
{
  "name": "aimond-token",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "hardhat test",
    "test:inv": "hardhat test test/InvestorVestingToken.test.ts",
    "test:fnd": "hardhat test test/FounderVestingToken.test.ts",
    "test:emp": "hardhat test test/EmployeeVestingToken.test.ts",
    "test:mock": "hardhat test test/MockVestingToken.test.ts",
    "test:loyalty": "hardhat test test/LoyaltyPoint.test.ts",
    "build": "hardhat compile",
    "localnode": "NODE_OPTIONS='--max-old-space-size=8192' yarn hardhat node --port 8545",
    "deploy:aimond:localnet": "hardhat run scripts/deploy-aimond-token.ts --network localnet",
    "deploy:airdrop:localnet": "hardhat run scripts/deploy-airdrop.ts --network localnet",
    "deploy:employee:localnet": "hardhat run scripts/deploy-employee-vesting-token.ts --network localnet",
    "deploy:founder:localnet": "hardhat run scripts/deploy-founder-vesting-token.ts --network localnet",
    "deploy:investor:localnet": "hardhat run scripts/deploy-investor-vesting-token.ts --network localnet",
    "deploy:all:localnet": "hardhat run scripts/deploy-all.ts --network localnet",
    "deploy:localnet": "hardhat run scripts/deploy.ts --network localnet",
    "deploy:aimond:testnet": "hardhat run scripts/deploy-aimond-token.ts --network bscTestnet",
    "deploy:employee:testnet": "hardhat run scripts/deploy-employee-vesting-token.ts --network bscTestnet",
    "deploy:founder:testnet": "hardhat run scripts/deploy-founder-vesting-token.ts --network bscTestnet",
    "deploy:investor:testnet": "hardhat run scripts/deploy-investor-vesting-token.ts --network bscTestnet",
    "deploy:mock:testnet": "hardhat run scripts/mocks/deploy-mock-vesting-token.ts --network bscTestnet",
    "deploy:all:testnet": "hardhat run scripts/deploy-all.ts --network bscTestnet",
    "deploy:testnet": "hardhat run scripts/deploy.ts --network bscTestnet",
    "create:keystore:loyalty": "hardhat run scripts/create-keystore.ts",
    "deploy:loyalty:bscTestnet": "hardhat run scripts/deploy-loyalty-point.ts --network bscTestnet",
    "info:loyalty:admin": "hardhat run scripts/get-loyalty-admin.ts --network bscTestnet"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@nomicfoundation/hardhat-chai-matchers": "^2.0.0",
    "@nomicfoundation/hardhat-ethers": "^3.0.0",
    "@nomicfoundation/hardhat-ignition": "^0.15.12",
    "@nomicfoundation/hardhat-ignition-ethers": "^0.15.0",
    "@nomicfoundation/hardhat-network-helpers": "^1.0.0",
    "@nomicfoundation/hardhat-toolbox": "^6.0.0",
    "@nomicfoundation/hardhat-verify": "^2.0.0",
    "@nomicfoundation/ignition-core": "^0.15.12",
    "@typechain/ethers-v6": "^0.5.0",
    "@typechain/hardhat": "^9.0.0",
    "@types/chai": "^5.2.2",
    "@types/mocha": "^10.0.10",
    "@types/node": "^24.0.10",
    "chai": "^4.3.7",
    "dotenv": "^17.0.1",
    "ethers": "^6.13.1",
    "hardhat": "^2.25.0",
    "hardhat-gas-reporter": "^2.3.0",
    "solidity-coverage": "^0.8.1",
    "ts-node": "^10.9.2",
    "typechain": "^8.3.0",
    "typescript": "^5.8.3"
  },
  "packageManager": "yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e",
  "dependencies": {
    "@openzeppelin/contracts": "^5.4.0",
    "@safe-global/protocol-kit": "^2.0.0",
    "@safe-global/safe-core-sdk-types": "^2.0.0",
    "keccak256": "^1.0.6",
    "merkletreejs": "^0.5.2"
  }
}

// ── ./scripts/create-keystore.ts ──────────────────────────────────────────────
import { ethers } from "ethers";
import * as fs from "fs";
import "dotenv/config";

async function main() {
  const privateKey = process.env.LOYALTY_POINT_ADMIN_KEY;
  if (!privateKey) {
    throw new Error("LOYALTY_POINT_ADMIN_KEY not found in .env file");
  }

  const password = process.env.LOYALTY_POINT_ADMIN_PASSWORD;
  if (!password) {
    throw new Error("LOYALTY_POINT_ADMIN_PASSWORD not found in .env file");
  }

  const wallet = new ethers.Wallet(privateKey);
  console.log(`Address: ${wallet.address}`);

  const keystore = await wallet.encrypt(password);

  const fileName = "keystore-loyalty-point-admin.json";
  fs.writeFileSync(fileName, keystore);

  console.log(`Keystore file created: ${fileName}`);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/deploy-aimond-token.ts ──────────────────────────────────────────────

import { ethers } from "hardhat";
import { isAddress, ZeroAddress } from "ethers";
import "dotenv/config";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying AimondToken with the account:", deployer.address);

  const initialOwner = process.env.INITIAL_OWNER;
  if (!initialOwner) {
    throw new Error("INITIAL_OWNER is not set in .env file");
  }
  if (!isAddress(initialOwner)) {
    throw new Error(`INITIAL_OWNER is invalid: ${initialOwner}`);
  }
  if (initialOwner === ZeroAddress) {
    throw new Error("INITIAL_OWNER cannot be the zero address");
  }
  if (initialOwner === "0x0000000000000000000000000000000000000000") {
    throw new Error("INITIAL_OWNER cannot be the zero address");
  }

  const aimondToken = await ethers.deployContract("AimondToken", [initialOwner]);
  await aimondToken.waitForDeployment();

  console.log("AimondToken deployed to:", aimondToken.target);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/deploy-all.ts ──────────────────────────────────────────────

import { ethers } from "hardhat";
import { isAddress, ZeroAddress } from "ethers";
import "dotenv/config";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);

  const initialOwner = process.env.INITIAL_OWNER;
  if (!initialOwner) {
    throw new Error("INITIAL_OWNER is not set in .env file");
  }
  if (!isAddress(initialOwner)) {
    throw new Error(`INITIAL_OWNER is invalid: ${initialOwner}`);
  }
  if (initialOwner === ZeroAddress) {
    throw new Error("INITIAL_OWNER cannot be the zero address");
  }

  const initialDistributorManager = process.env.INITIAL_DISTRIBUTOR_MANAGER;
  if (!initialDistributorManager) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER is not set in .env file");
  }
  if (!isAddress(initialDistributorManager)) {
    throw new Error(`INITIAL_DISTRIBUTOR_MANAGER is invalid: ${initialDistributorManager}`);
  }
  if (initialDistributorManager === ZeroAddress) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER cannot be the zero address");
  }

  // Deploy AimondToken
  const aimondToken = await ethers.deployContract("AimondToken", [initialOwner]);
  await aimondToken.waitForDeployment();
  console.log("AimondToken deployed to:", aimondToken.target);

  // Deploy EmployeeVestingToken
  const employeeVestingToken = await ethers.deployContract("EmployeeVestingToken", [
    initialOwner,
    initialDistributorManager,
    aimondToken.target
  ]);
  await employeeVestingToken.waitForDeployment();
  console.log("EmployeeVestingToken deployed to:", employeeVestingToken.target);

  // Deploy FounderVestingToken
  const founderVestingToken = await ethers.deployContract("FounderVestingToken", [
    initialOwner,
    initialDistributorManager,
    aimondToken.target
  ]);
  await founderVestingToken.waitForDeployment();
  console.log("FounderVestingToken deployed to:", founderVestingToken.target);

  // Deploy InvestorVestingToken
  const investorVestingToken = await ethers.deployContract("InvestorVestingToken", [
    initialOwner,
    initialDistributorManager,
    aimondToken.target
  ]);
  await investorVestingToken.waitForDeployment();
  console.log("InvestorVestingToken deployed to:", investorVestingToken.target);

}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/deploy-employee-vesting-token.ts ──────────────────────────────────────────────

import { ethers } from "hardhat";
import { isAddress, ZeroAddress } from "ethers";
import "dotenv/config";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);

  const initialOwner = process.env.INITIAL_OWNER;
  if (!initialOwner) {
    throw new Error("INITIAL_OWNER is not set in .env file");
  }
  if (!isAddress(initialOwner)) {
    throw new Error(`INITIAL_OWNER is invalid: ${initialOwner}`);
  }
  if (initialOwner === ZeroAddress) {
    throw new Error("INITIAL_OWNER cannot be the zero address");
  }

  const initialDistributorManager = process.env.INITIAL_DISTRIBUTOR_MANAGER;
  if (!initialDistributorManager) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER is not set in .env file");
  }
  if (!isAddress(initialDistributorManager)) {
    throw new Error(`INITIAL_DISTRIBUTOR_MANAGER is invalid: ${initialDistributorManager}`);
  }
  if (initialDistributorManager === ZeroAddress) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER cannot be the zero address");
  }

  const aimondTokenAddress = process.env.AIMOND_ADDRESS;
  if (!aimondTokenAddress) {
    throw new Error("AIMOND_ADDRESS is not set in .env file");
  }
  if (!isAddress(aimondTokenAddress)) {
    throw new Error(`AIMOND_ADDRESS is invalid: ${aimondTokenAddress}`);
  }
  if (aimondTokenAddress === ZeroAddress) {
    throw new Error("AIMOND_ADDRESS cannot be the zero address");
  }

  // Deploy EmployeeVestingToken
  const employeeVestingToken = await ethers.deployContract("EmployeeVestingToken", [
    initialOwner,
    initialDistributorManager,
    aimondTokenAddress
  ]);
  await employeeVestingToken.waitForDeployment();

  console.log("EmployeeVestingToken deployed to:", employeeVestingToken.target);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/deploy-founder-vesting-token.ts ──────────────────────────────────────────────

import { ethers } from "hardhat";
import { isAddress, ZeroAddress } from "ethers";
import "dotenv/config";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);

  const initialOwner = process.env.INITIAL_OWNER;
  if (!initialOwner) {
    throw new Error("INITIAL_OWNER is not set in .env file");
  }
  if (!isAddress(initialOwner)) {
    throw new Error(`INITIAL_OWNER is invalid: ${initialOwner}`);
  }
  if (initialOwner === ZeroAddress) {
    throw new Error("INITIAL_OWNER cannot be the zero address");
  }

  const initialDistributorManager = process.env.INITIAL_DISTRIBUTOR_MANAGER;
  if (!initialDistributorManager) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER is not set in .env file");
  }
  if (!isAddress(initialDistributorManager)) {
    throw new Error(`INITIAL_DISTRIBUTOR_MANAGER is invalid: ${initialDistributorManager}`);
  }
  if (initialDistributorManager === ZeroAddress) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER cannot be the zero address");
  }

  const aimondTokenAddress = process.env.AIMOND_ADDRESS;
  if (!aimondTokenAddress) {
    throw new Error("AIMOND_ADDRESS is not set in .env file");
  }
  if (!isAddress(aimondTokenAddress)) {
    throw new Error(`AIMOND_ADDRESS is invalid: ${aimondTokenAddress}`);
  }
  if (aimondTokenAddress === ZeroAddress) {
    throw new Error("AIMOND_ADDRESS cannot be the zero address");
  }

  // Deploy FounderVestingToken
  const founderVestingToken = await ethers.deployContract("FounderVestingToken", [
    initialOwner,
    initialDistributorManager,
    aimondTokenAddress
  ]);
  await founderVestingToken.waitForDeployment();

  console.log("FounderVestingToken deployed to:", founderVestingToken.target);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/deploy-investor-vesting-token.ts ──────────────────────────────────────────────

import { ethers } from "hardhat";
import { isAddress, ZeroAddress } from "ethers";
import "dotenv/config";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);

  const initialOwner = process.env.INITIAL_OWNER;
  if (!initialOwner) {
    throw new Error("INITIAL_OWNER is not set in .env file");
  }
  if (!isAddress(initialOwner)) {
    throw new Error(`INITIAL_OWNER is invalid: ${initialOwner}`);
  }
  if (initialOwner === ZeroAddress) {
    throw new Error("INITIAL_OWNER cannot be the zero address");
  }

  const initialDistributorManager = process.env.INITIAL_DISTRIBUTOR_MANAGER;
  if (!initialDistributorManager) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER is not set in .env file");
  }
  if (!isAddress(initialDistributorManager)) {
    throw new Error(`INITIAL_DISTRIBUTOR_MANAGER is invalid: ${initialDistributorManager}`);
  }
  if (initialDistributorManager === ZeroAddress) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER cannot be the zero address");
  }

  const aimondTokenAddress = process.env.AIMOND_ADDRESS;
  if (!aimondTokenAddress) {
    throw new Error("AIMOND_ADDRESS is not set in .env file");
  }
  if (!isAddress(aimondTokenAddress)) {
    throw new Error(`AIMOND_ADDRESS is invalid: ${aimondTokenAddress}`);
  }
  if (aimondTokenAddress === ZeroAddress) {
    throw new Error("AIMOND_ADDRESS cannot be the zero address");
  }

  // Deploy InvestorVestingToken
  const investorVestingToken = await ethers.deployContract("InvestorVestingToken", [
    initialOwner,
    initialDistributorManager,
    aimondTokenAddress
  ]);
  await investorVestingToken.waitForDeployment();

  console.log("InvestorVestingToken deployed to:", investorVestingToken.target);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/deploy-loyalty-point.ts ──────────────────────────────────────────────
import { ethers } from "hardhat";
import { isAddress, ZeroHash } from "ethers";
import "dotenv/config";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying LoyaltyPoint with the account:", deployer.address);

  const aimondAddress = process.env.AIMOND_ADDRESS;
  if (!aimondAddress) {
    throw new Error("AIMOND_ADDRESS is not set in .env file");
  }
  if (!isAddress(aimondAddress)) {
    throw new Error(`AIMOND_ADDRESS is invalid: ${aimondAddress}`);
  }

  const loyaltyPointAdminKey = process.env.LOYALTY_POINT_ADMIN_KEY;
  if (!loyaltyPointAdminKey) {
    throw new Error("LOYALTY_POINT_ADMIN_KEY is not set in .env file");
  }
  const loyaltyPointAdminWallet = new ethers.Wallet(loyaltyPointAdminKey);
  const loyaltyPointAdminAddress = loyaltyPointAdminWallet.address;

  const loyaltyPoint = await ethers.deployContract("LoyaltyPoint", [
    aimondAddress,
    ZeroHash,
    loyaltyPointAdminAddress,
  ]);
  await loyaltyPoint.waitForDeployment();

  console.log("LoyaltyPoint deployed to:", loyaltyPoint.target);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/get-loyalty-admin.ts ──────────────────────────────────────────────
import { ethers } from "hardhat";
import "dotenv/config";

async function main() {
  const loyaltyPointAddress = process.env.LOYALTY_POINT_ADDRESS;
  if (!loyaltyPointAddress) {
    throw new Error("LOYALTY_POINT_ADDRESS not found in .env file");
  }

  const loyaltyPointAdminKey = process.env.LOYALTY_POINT_ADMIN_KEY;
  if (!loyaltyPointAdminKey) {
    throw new Error("LOYALTY_POINT_ADMIN_KEY not found in .env file");
  }
  const loyaltyPointAdminWallet = new ethers.Wallet(loyaltyPointAdminKey);
  const loyaltyPointAdminAddress = loyaltyPointAdminWallet.address;

  const loyaltyPoint = await ethers.getContractAt("LoyaltyPoint", loyaltyPointAddress);

  const ADMIN_ROLE = ethers.keccak256(ethers.toUtf8Bytes("ADMIN_ROLE"));

  const isAdmin = await loyaltyPoint.hasRole(ADMIN_ROLE, loyaltyPointAdminAddress);

  console.log(`Is ${loyaltyPointAdminAddress} an admin? ${isAdmin}`);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./scripts/mocks/deploy-mock-vesting-token.ts ──────────────────────────────────────────────

import { ethers } from "hardhat";
import { isAddress, ZeroAddress } from "ethers";
import "dotenv/config";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);

  const initialOwner = process.env.INITIAL_OWNER;
  if (!initialOwner) {
    throw new Error("INITIAL_OWNER is not set in .env file");
  }
  if (!isAddress(initialOwner)) {
    throw new Error(`INITIAL_OWNER is invalid: ${initialOwner}`);
  }
  if (initialOwner === ZeroAddress) {
    throw new Error("INITIAL_OWNER cannot be the zero address");
  }

  const initialDistributorManager = process.env.INITIAL_DISTRIBUTOR_MANAGER;
  if (!initialDistributorManager) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER is not set in .env file");
  }
  if (!isAddress(initialDistributorManager)) {
    throw new Error(`INITIAL_DISTRIBUTOR_MANAGER is invalid: ${initialDistributorManager}`);
  }
  if (initialDistributorManager === ZeroAddress) {
    throw new Error("INITIAL_DISTRIBUTOR_MANAGER cannot be the zero address");
  }

  const aimondTokenAddress = process.env.AIMOND_ADDRESS;
  if (!aimondTokenAddress) {
    throw new Error("AIMOND_ADDRESS is not set in .env file");
  }
  if (!isAddress(aimondTokenAddress)) {
    throw new Error(`AIMOND_ADDRESS is invalid: ${aimondTokenAddress}`);
  }
  if (aimondTokenAddress === ZeroAddress) {
    throw new Error("AIMOND_ADDRESS cannot be the zero address");
  }

  // Deploy MockVestingToken
  const mockVestingToken = await ethers.deployContract("MockVestingToken", [
    initialOwner,
    initialDistributorManager,
    aimondTokenAddress,
    1, // cliffDurationInDays
    11, // vestingDurationInDays
    10  // installmentCount
  ]);
  await mockVestingToken.waitForDeployment();

  console.log("MockVestingToken deployed to:", mockVestingToken.target);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

// ── ./test/AccessControl.test.ts ──────────────────────────────────────────────
import { expect } from "chai";
import { ethers } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { EmployeeVestingToken, AimondToken } from "../typechain-types";

describe("EmployeeVestingToken AccessControl", function () {
    let empVestingToken: EmployeeVestingToken;
    let aimondToken: AimondToken;
    let owner: SignerWithAddress;
    let initialDistributorManager: SignerWithAddress;
    let addr2: SignerWithAddress;
    let addr3: SignerWithAddress;
    let addrs: SignerWithAddress[];

    const DEFAULT_ADMIN_ROLE = ethers.ZeroHash;
    const DISTRIBUTOR_ROLE = ethers.keccak256(ethers.toUtf8Bytes("DISTRIBUTOR_ROLE"));
    const DISTRIBUTOR_MANAGER_ROLE = ethers.keccak256(ethers.toUtf8Bytes("DISTRIBUTOR_MANAGER_ROLE"));

    beforeEach(async function () {
        [owner, initialDistributorManager, addr2, addr3, ...addrs] = await ethers.getSigners();

        const AimondTokenFactory = await ethers.getContractFactory("AimondToken");
        aimondToken = await AimondTokenFactory.deploy(owner.address);
        await aimondToken.waitForDeployment();

        const EmployeeVestingTokenFactory = await ethers.getContractFactory("EmployeeVestingToken");
        empVestingToken = await EmployeeVestingTokenFactory.deploy(
            owner.address,
            initialDistributorManager.address,
            aimondToken.target
        );
        await empVestingToken.waitForDeployment();
    });

    describe("Role Assignments on Deployment", function () {
        it("Should grant DEFAULT_ADMIN_ROLE to the initialOwner", async function () {
            expect(await empVestingToken.hasRole(DEFAULT_ADMIN_ROLE, owner.address)).to.be.true;
        });

        it("Should grant DISTRIBUTOR_MANAGER_ROLE to initialOwner and initialDistributorManager", async function () {
            expect(await empVestingToken.hasRole(DISTRIBUTOR_MANAGER_ROLE, owner.address)).to.be.true;
            expect(await empVestingToken.hasRole(DISTRIBUTOR_MANAGER_ROLE, initialDistributorManager.address)).to.be.true;
        });

        it("Should grant DISTRIBUTOR_ROLE to initialOwner and initialDistributorManager", async function () {
            expect(await empVestingToken.hasRole(DISTRIBUTOR_ROLE, owner.address)).to.be.true;
            expect(await empVestingToken.hasRole(DISTRIBUTOR_ROLE, initialDistributorManager.address)).to.be.true;
        });
    });

    describe("Distributor Manager Management", function () {
        it("Should allow DEFAULT_ADMIN_ROLE to add a new distributor manager", async function () {
            await expect(empVestingToken.connect(owner).addDistributorManager(addr2.address))
                .to.emit(empVestingToken, "RoleGranted")
                .withArgs(DISTRIBUTOR_MANAGER_ROLE, addr2.address, owner.address);
            expect(await empVestingToken.hasRole(DISTRIBUTOR_MANAGER_ROLE, addr2.address)).to.be.true;
        });

        it("Should allow DEFAULT_ADMIN_ROLE to remove a distributor manager", async function () {
            await empVestingToken.connect(owner).addDistributorManager(addr2.address);
            expect(await empVestingToken.hasRole(DISTRIBUTOR_MANAGER_ROLE, addr2.address)).to.be.true;

            await expect(empVestingToken.connect(owner).removeDistributorManager(addr2.address))
                .to.emit(empVestingToken, "RoleRevoked")
                .withArgs(DISTRIBUTOR_MANAGER_ROLE, addr2.address, owner.address);
            expect(await empVestingToken.hasRole(DISTRIBUTOR_MANAGER_ROLE, addr2.address)).to.be.false;
        });

        it("Should not allow non-admin to add or remove a distributor manager", async function () {
            await expect(empVestingToken.connect(initialDistributorManager).addDistributorManager(addr2.address))
                .to.be.revertedWithCustomError(empVestingToken, "AccessControlUnauthorizedAccount")
                .withArgs(initialDistributorManager.address, DEFAULT_ADMIN_ROLE);

            await expect(empVestingToken.connect(initialDistributorManager).removeDistributorManager(owner.address))
                .to.be.revertedWithCustomError(empVestingToken, "AccessControlUnauthorizedAccount")
                .withArgs(initialDistributorManager.address, DEFAULT_ADMIN_ROLE);
        });
    });

    describe("Distributor Management", function () {
        it("Should allow DISTRIBUTOR_MANAGER_ROLE to add a distributor", async function () {
            await expect(empVestingToken.connect(initialDistributorManager).addDistributor(addr2.address))
                .to.emit(empVestingToken, "DistributorAdded")
                .withArgs(addr2.address);
            expect(await empVestingToken.hasRole(DISTRIBUTOR_ROLE, addr2.address)).to.be.true;
        });

        it("Should not allow non-DISTRIBUTOR_MANAGER_ROLE to add a distributor", async function () {
            await expect(empVestingToken.connect(addr2).addDistributor(addr3.address))
                .to.be.revertedWithCustomError(empVestingToken, "AccessControlUnauthorizedAccount")
                .withArgs(addr2.address, DISTRIBUTOR_MANAGER_ROLE);
        });

        it("Should allow DISTRIBUTOR_MANAGER_ROLE to remove a distributor", async function () {
            await empVestingToken.connect(initialDistributorManager).addDistributor(addr2.address);
            expect(await empVestingToken.hasRole(DISTRIBUTOR_ROLE, addr2.address)).to.be.true;

            await expect(empVestingToken.connect(initialDistributorManager).removeDistributor(addr2.address))
                .to.emit(empVestingToken, "DistributorRemoved")
                .withArgs(addr2.address);
            expect(await empVestingToken.hasRole(DISTRIBUTOR_ROLE, addr2.address)).to.be.false;
        });

        it("Should not allow non-DISTRIBUTOR_MANAGER_ROLE to remove a distributor", async function () {
            await empVestingToken.connect(initialDistributorManager).addDistributor(addr2.address);
            await expect(empVestingToken.connect(addr3).removeDistributor(addr2.address))
                .to.be.revertedWithCustomError(empVestingToken, "AccessControlUnauthorizedAccount")
                .withArgs(addr3.address, DISTRIBUTOR_MANAGER_ROLE);
        });
    });
});
// ── ./test/EmployeeVestingToken.test.ts ──────────────────────────────────────────────
import { ethers } from "hardhat";
import { expect } from "chai";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { AimondToken, EmployeeVestingToken } from "../typechain-types";
import * as helpers from "@nomicfoundation/hardhat-network-helpers";

import { formatTimestamp, formatAmdBalance, formatAimBalance } from "./utils/time";

import { TOTAL_VESTING_AMOUNT_EMPLOYEE } from "./constants";

describe("EmployeeVestingToken Scenarios", function () {
    async function deployVestingFixture() {
        const [owner, beneficiary] = await ethers.getSigners();
        const amdToken = await ethers.deployContract("AimondToken", [owner.address]);
        const vestingContract = await ethers.deployContract("EmployeeVestingToken", [owner.address, owner.address, await amdToken.getAddress()]);
        
        const amdDecimals = await amdToken.decimals();

        const scheduleAmount = ethers.parseUnits("10000", 18);

        // Transfer AMD to vesting contract
        const totalAmdForVesting = TOTAL_VESTING_AMOUNT_EMPLOYEE; // Total amount for vesting
        await amdToken.connect(owner).transfer(await vestingContract.getAddress(), totalAmdForVesting);

        return { vestingContract, amdToken, owner, beneficiary, scheduleAmount, amdDecimals };
    }

    it("Should not allow claiming before cliff ends", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);
        const twoSecBeforeCliffEnds = cliffEndsTimestamp - 2;

        const initialBalance = await amdToken.balanceOf(beneficiary.address);

        // IMPORTANT: There is a 1-second offset with `helpers.time.increaseTo`.
        // Calling `increaseTo(T)` results in the next block having a timestamp of `T + 1`.
        await helpers.time.increaseTo(twoSecBeforeCliffEnds);
        
        const releasableAmount = await vestingContract.getCurrentlyReleasableAmount(beneficiary.address);
        expect(releasableAmount).to.equal(0);

        await vestingContract.connect(owner).releaseTo(beneficiary.address);
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(initialBalance);
    });

    it("Should allow claiming right after cliff ends", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount, amdDecimals } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration) - 1;

        await helpers.time.increaseTo(cliffEndsTimestamp); // one sec before cliff end
        await vestingContract.connect(owner).releaseTo(beneficiary.address);

        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(scheduleAmount);
    });

    it("Should allow claiming one sec after cliff ends", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount, amdDecimals } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);

        await helpers.time.increaseTo(cliffEndsTimestamp); // Exactly at cliff end
        await vestingContract.connect(owner).releaseTo(beneficiary.address);

        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(scheduleAmount);
    });

    it("Should allow claiming all tokens after full vesting period", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount, amdDecimals } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const fullVestingEndsTimestamp = Number(globalStartTime) + Number(schedule.totalVestingDuration);
        

        await helpers.time.increaseTo(fullVestingEndsTimestamp);
        await vestingContract.connect(owner).releaseTo(beneficiary.address);

        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(scheduleAmount);
    });

    it("Should release tokens correctly over each installment", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount, amdDecimals } = await helpers.loadFixture(deployVestingFixture);

        await vestingContract.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(await helpers.time.latest());

        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();

        let totalClaimedAmd = BigInt(0);

        const installmentDuration = schedule.releaseDuration / schedule.installmentCount;

        const expectedAmount = scheduleAmount / schedule.installmentCount;

        for (let i = 0; i < schedule.installmentCount; i++) {
            const newTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration) + Number(installmentDuration) * i - 1;
        
            await helpers.time.increaseTo(newTimestamp);
            await vestingContract.connect(owner).releaseTo(beneficiary.address);

            totalClaimedAmd += expectedAmount;
            expect(await amdToken.balanceOf(beneficiary.address)).to.equal(totalClaimedAmd);
        }
    });

    it("Should release tokens for multiple beneficiaries via batch", async function () {
        const [owner, beneficiary1, beneficiary2] = await ethers.getSigners();
        const amdToken = await ethers.deployContract("AimondToken", [owner.address]);
        const vestingContract = await ethers.deployContract(
            "EmployeeVestingToken",
            [owner.address, owner.address, await amdToken.getAddress()]
        );

        const scheduleAmount1 = ethers.parseUnits("10000", 18);
        const scheduleAmount2 = ethers.parseUnits("20000", 18);
        const totalAmdForVesting = TOTAL_VESTING_AMOUNT_EMPLOYEE;
        await amdToken
            .connect(owner)
            .transfer(await vestingContract.getAddress(), totalAmdForVesting);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract
            .connect(owner)
            .createVesting(beneficiary1.address, scheduleAmount1);
        await vestingContract
            .connect(owner)
            .createVesting(beneficiary2.address, scheduleAmount2);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);

        const schedule = await vestingContract.vestingSchedules(
            beneficiary1.address
        );
        const globalStartTime = await vestingContract.globalStartTime();
        const fullVestingEndsTimestamp =
            Number(globalStartTime) +
            Number(schedule.totalVestingDuration);

        await helpers.time.increaseTo(fullVestingEndsTimestamp);
        await vestingContract
            .connect(owner)
            .releaseToBatch([beneficiary1.address, beneficiary2.address]);

        expect(await amdToken.balanceOf(beneficiary1.address)).to.equal(
            scheduleAmount1
        );
        expect(await amdToken.balanceOf(beneficiary2.address)).to.equal(
            scheduleAmount2
        );
    });
});
// ── ./test/FounderVestingToken.test.ts ──────────────────────────────────────────────
import { ethers } from "hardhat";
import { expect } from "chai";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { AimondToken, FounderVestingToken } from "../typechain-types";
import * as helpers from "@nomicfoundation/hardhat-network-helpers";

import { formatTimestamp, formatAmdBalance, formatAimBalance } from "./utils/time";

import { TOTAL_VESTING_AMOUNT_FOUNDER } from "./constants";

describe("FounderVestingToken Scenarios", function () {
    async function deployVestingFixture() {
        const [owner, beneficiary] = await ethers.getSigners();
        const amdToken = await ethers.deployContract("AimondToken", [owner.address]);
        const vestingToken = await ethers.deployContract("FounderVestingToken", [owner.address, owner.address, await amdToken.getAddress()]);
        
        const amdDecimals = await amdToken.decimals();

        const scheduleAmount = ethers.parseUnits("10000", 18);

        // Transfer AMD to vesting contract
        const totalAmdForVesting = TOTAL_VESTING_AMOUNT_FOUNDER; // Total amount for vesting
        await amdToken.connect(owner).transfer(await vestingToken.getAddress(), totalAmdForVesting);

        return { vestingToken, amdToken, owner, beneficiary, scheduleAmount, amdDecimals };
    }

    it("Should not allow claiming before cliff ends", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);
        const twoSecBeforeCliffEnds = cliffEndsTimestamp - 2;

        const initialBalance = await amdToken.balanceOf(beneficiary.address);

        // IMPORTANT: There is a 1-second offset with `helpers.time.increaseTo`.
        // Calling `increaseTo(T)` results in the next block having a timestamp of `T + 1`.
        await helpers.time.increaseTo(twoSecBeforeCliffEnds);
        
        const releasableAmount = await vestingToken.getCurrentlyReleasableAmount(beneficiary.address);
        expect(releasableAmount).to.equal(0);

        await vestingToken.connect(owner).releaseTo(beneficiary.address);
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(initialBalance);
    });

    it("Should allow claiming right after cliff ends", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration) - 1;

        await helpers.time.increaseTo(cliffEndsTimestamp); // one sec before cliff end
        await vestingToken.connect(owner).releaseTo(beneficiary.address);

        const expectedAmount = scheduleAmount / schedule.installmentCount;
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(expectedAmount);
    });

    it("Should allow claiming one sec after cliff ends", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);

        await helpers.time.increaseTo(cliffEndsTimestamp); // Exactly at cliff end
        await vestingToken.connect(owner).releaseTo(beneficiary.address);

        const expectedAmount = scheduleAmount / schedule.installmentCount;
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(expectedAmount);
    });

    it("Should allow claiming all tokens after full vesting period", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount, amdDecimals } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const fullVestingEndsTimestamp = Number(globalStartTime) + Number(schedule.totalVestingDuration);
        

        await helpers.time.increaseTo(fullVestingEndsTimestamp);
        await vestingToken.connect(owner).releaseTo(beneficiary.address);

        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(scheduleAmount);
    });

    it("Should release tokens correctly over each installment", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount, amdDecimals } = await helpers.loadFixture(deployVestingFixture);

        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(await helpers.time.latest());

        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();

        let totalClaimedAmd = BigInt(0);

        const installmentDuration = schedule.releaseDuration / schedule.installmentCount;

        const expectedAmount = scheduleAmount / schedule.installmentCount;

        for (let i = 0; i < schedule.installmentCount; i++) {
            const newTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration) + Number(installmentDuration) * i - 1;
        
            await helpers.time.increaseTo(newTimestamp);
            await vestingToken.connect(owner).releaseTo(beneficiary.address);

            totalClaimedAmd += expectedAmount;
            expect(await amdToken.balanceOf(beneficiary.address)).to.equal(totalClaimedAmd);
        }
    });

    it("Should release tokens for multiple beneficiaries via batch", async function () {
        const [owner, beneficiary1, beneficiary2] = await ethers.getSigners();
        const amdToken = await ethers.deployContract("AimondToken", [owner.address]);
        const vestingToken = await ethers.deployContract(
            "FounderVestingToken",
            [owner.address, owner.address, await amdToken.getAddress()]
        );

        const scheduleAmount1 = ethers.parseUnits("10000", 18);
        const scheduleAmount2 = ethers.parseUnits("20000", 18);
        const totalAmdForVesting = TOTAL_VESTING_AMOUNT_FOUNDER;
        await amdToken
            .connect(owner)
            .transfer(await vestingToken.getAddress(), totalAmdForVesting);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken
            .connect(owner)
            .createVesting(beneficiary1.address, scheduleAmount1);
        await vestingToken
            .connect(owner)
            .createVesting(beneficiary2.address, scheduleAmount2);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);

        const schedule = await vestingToken.vestingSchedules(
            beneficiary1.address
        );
        const globalStartTime = await vestingToken.globalStartTime();
        const fullVestingEndsTimestamp =
            Number(globalStartTime) +
            Number(schedule.totalVestingDuration);

        await helpers.time.increaseTo(fullVestingEndsTimestamp);
        await vestingToken
            .connect(owner)
            .releaseToBatch([beneficiary1.address, beneficiary2.address]);

        expect(await amdToken.balanceOf(beneficiary1.address)).to.equal(
            scheduleAmount1
        );
        expect(await amdToken.balanceOf(beneficiary2.address)).to.equal(
            scheduleAmount2
        );
    });
});
// ── ./test/InvestorVestingToken.test.ts ──────────────────────────────────────────────
import { ethers } from "hardhat";
import { expect } from "chai";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { AimondToken, InvestorVestingToken } from "../typechain-types";
import * as helpers from "@nomicfoundation/hardhat-network-helpers";

import { formatTimestamp, formatAmdBalance, formatAimBalance } from "./utils/time";

import { TOTAL_VESTING_AMOUNT_INVESTOR } from "./constants";

describe("InvestorVestingToken Scenarios", function () {
    async function deployVestingFixture() {
        const [owner, beneficiary] = await ethers.getSigners();
        const amdToken = await ethers.deployContract("AimondToken", [owner.address]);
        const vestingToken = await ethers.deployContract("InvestorVestingToken", [owner.address, owner.address, await amdToken.getAddress()]);
        
        const amdDecimals = await amdToken.decimals();

        const scheduleAmount = ethers.parseUnits("10001", 18);

        // Transfer AMD to vesting contract
        const totalAmdForVesting = TOTAL_VESTING_AMOUNT_INVESTOR; // Total amount for vesting
        await amdToken.connect(owner).transfer(await vestingToken.getAddress(), totalAmdForVesting);

        return { vestingToken, amdToken, owner, beneficiary, scheduleAmount, amdDecimals };
    }

    it("Should not allow claiming before cliff ends", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);
        const twoSecBeforeCliffEnds = cliffEndsTimestamp - 2;

        const initialBalance = await amdToken.balanceOf(beneficiary.address);

        // IMPORTANT: There is a 1-second offset with `helpers.time.increaseTo`.
        // Calling `increaseTo(T)` results in the next block having a timestamp of `T + 1`.
        // To test the state *before* the cliff ends, we must jump to at least 2 seconds before.
        // Jumping to `cliffEndsTimestamp - 2` ensures the claim transaction occurs at `cliffEndsTimestamp - 1`.
        await helpers.time.increaseTo(twoSecBeforeCliffEnds);
        
        const releasableAmount = await vestingToken.getCurrentlyReleasableAmount(beneficiary.address);
        expect(releasableAmount).to.equal(0);

        await vestingToken.connect(beneficiary).claim();
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(initialBalance);
    });

    it("Should allow claiming right after cliff ends", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration) - 1;

        await helpers.time.increaseTo(cliffEndsTimestamp); // one sec before cliff end
        await vestingToken.connect(beneficiary).claim();

        const expectedAmount = scheduleAmount / schedule.installmentCount;
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(expectedAmount);
    });

    it("Should allow claiming one sec after cliff ends", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);

        await helpers.time.increaseTo(cliffEndsTimestamp); // Exactly at cliff end
        await vestingToken.connect(beneficiary).claim();

        const expectedAmount = scheduleAmount / schedule.installmentCount;
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(expectedAmount);
    });

    it("Should allow claiming all tokens after full vesting period", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount, amdDecimals } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);
        
        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();
        const fullVestingEndsTimestamp = Number(globalStartTime) + Number(schedule.totalVestingDuration);
        

        await helpers.time.increaseTo(fullVestingEndsTimestamp);
        await vestingToken.connect(beneficiary).claim();

        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(scheduleAmount);
    });

    it("Should release tokens correctly over each installment", async function () {
        const { vestingToken, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        await vestingToken.connect(owner).createVesting(beneficiary.address, scheduleAmount);
        await vestingToken.connect(owner).setGlobalStartTime(await helpers.time.latest());

        const schedule = await vestingToken.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingToken.globalStartTime();

        let totalClaimedAmd = BigInt(0);

        const installmentDuration = schedule.releaseDuration / schedule.installmentCount;

        const expectedAmount = scheduleAmount / schedule.installmentCount;

        for (let i = 0; i < schedule.installmentCount; i++) {
            const newTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration) + Number(installmentDuration) * i - 1;
        
            // Note: `increaseTo(T)` results in the next block timestamp being `T + 1`.
            await helpers.time.increaseTo(newTimestamp);
            await vestingToken.connect(beneficiary).claim();

            totalClaimedAmd += expectedAmount;
            expect(await amdToken.balanceOf(beneficiary.address)).to.equal(totalClaimedAmd);
        }
    });

    it("Should release tokens for multiple beneficiaries via batch", async function () {
        const [owner, beneficiary1, beneficiary2] = await ethers.getSigners();
        const amdToken = await ethers.deployContract("AimondToken", [owner.address]);
        const vestingToken = await ethers.deployContract(
            "InvestorVestingToken",
            [owner.address, owner.address, await amdToken.getAddress()]
        );

        const scheduleAmount1 = ethers.parseUnits("10001", 18);
        const scheduleAmount2 = ethers.parseUnits("20002", 18);
        const totalAmdForVesting = TOTAL_VESTING_AMOUNT_INVESTOR;
        await amdToken
            .connect(owner)
            .transfer(await vestingToken.getAddress(), totalAmdForVesting);

        const listingTimestamp = await helpers.time.latest();
        await vestingToken
            .connect(owner)
            .createVesting(beneficiary1.address, scheduleAmount1);
        await vestingToken
            .connect(owner)
            .createVesting(beneficiary2.address, scheduleAmount2);
        await vestingToken.connect(owner).setGlobalStartTime(listingTimestamp);

        const schedule = await vestingToken.vestingSchedules(
            beneficiary1.address
        );
        const globalStartTime = await vestingToken.globalStartTime();
        const fullVestingEndsTimestamp =
            Number(globalStartTime) +
            Number(schedule.totalVestingDuration);

        await helpers.time.increaseTo(fullVestingEndsTimestamp);
        await vestingToken
            .connect(owner)
            .releaseToBatch([beneficiary1.address, beneficiary2.address]);

        expect(await amdToken.balanceOf(beneficiary1.address)).to.equal(
            scheduleAmount1
        );
        expect(await amdToken.balanceOf(beneficiary2.address)).to.equal(
            scheduleAmount2
        );
    });
});
// ── ./test/LoyaltyPoint.test.ts ──────────────────────────────────────────────
import { expect } from "chai";
import { ethers } from "hardhat";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { LoyaltyPoint, AimondToken } from "../typechain-types";

describe("LoyaltyPoint", function () {
    let loyaltyPoint: LoyaltyPoint;
    let aimondToken: AimondToken;
    let owner: SignerWithAddress;
    let admin: SignerWithAddress;
    let other: SignerWithAddress;

    const ADMIN_ROLE = ethers.keccak256(ethers.toUtf8Bytes("ADMIN_ROLE"));
    const DEFAULT_ADMIN_ROLE = ethers.ZeroHash;

    beforeEach(async function () {
        [owner, admin, other] = await ethers.getSigners();

        const AimondTokenFactory = await ethers.getContractFactory("AimondToken");
        aimondToken = await AimondTokenFactory.deploy(owner.address);
        await aimondToken.waitForDeployment();

        const LoyaltyPointFactory = await ethers.getContractFactory("LoyaltyPoint");
        loyaltyPoint = await LoyaltyPointFactory.deploy(
            aimondToken.target,
            ethers.ZeroHash,
            admin.address
        );
        await loyaltyPoint.waitForDeployment();
    });

    describe("Deployment", function () {
        it("Should set the right admin", async function () {
            expect(await loyaltyPoint.hasRole(ADMIN_ROLE, admin.address)).to.be.true;
        });

        it("Should grant DEFAULT_ADMIN_ROLE to the deployer", async function () {
            expect(await loyaltyPoint.hasRole(DEFAULT_ADMIN_ROLE, owner.address)).to.be.true;
        });

        it("Should grant ADMIN_ROLE to the deployer", async function () {
            expect(await loyaltyPoint.hasRole(ADMIN_ROLE, owner.address)).to.be.true;
        });
    });

    describe("Admin Role", function () {
        it("Should allow admin to update root", async function () {
            const newRoot = ethers.keccak256(ethers.toUtf8Bytes("new_root"));
            await expect(loyaltyPoint.connect(owner).updateRoot(newRoot))
                .to.emit(loyaltyPoint, "RootUpdated")
                .withArgs(newRoot);
            expect(await loyaltyPoint.merkleRoot()).to.equal(newRoot);
        });

        it("Should not allow non-admin to update root", async function () {
            const newRoot = ethers.keccak256(ethers.toUtf8Bytes("new_root"));
            await expect(loyaltyPoint.connect(other).updateRoot(newRoot))
                .to.be.revertedWithCustomError(loyaltyPoint, "AccessControlUnauthorizedAccount")
                .withArgs(other.address, DEFAULT_ADMIN_ROLE);
        });
    });
});
// ── ./test/MockVestingToken.test.ts ──────────────────────────────────────────────
import { ethers } from "hardhat";
import { expect } from "chai";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { AimondToken, MockVestingToken } from "../typechain-types";
import * as helpers from "@nomicfoundation/hardhat-network-helpers";

describe("MockVestingToken Scenarios", function () {
    async function deployVestingFixture() {
        const [owner, beneficiary] = await ethers.getSigners();
        const amdToken = await ethers.deployContract("AimondToken", [owner.address]);
        const vestingContract = await ethers.deployContract("MockVestingToken", [owner.address, owner.address, await amdToken.getAddress(), 1, 11, 10]);

        const scheduleAmount = ethers.parseUnits("1000", 18);
        const totalAmdForVesting = ethers.parseUnits("10000", 18);
        await amdToken.connect(owner).transfer(await vestingContract.getAddress(), totalAmdForVesting);

        return { vestingContract, amdToken, owner, beneficiary, scheduleAmount };
    }

    it("Should not allow claiming before cliff ends", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVestingSchedule(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);

        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);

        // IMPORTANT: There is a 1-second offset with `helpers.time.increaseTo`.
        // Calling `increaseTo(T)` results in the next block having a timestamp of `T + 1`.
        await helpers.time.increaseTo(cliffEndsTimestamp - 5); // 5 seconds before cliff ends

        const releasableAmount = await vestingContract.getCurrentlyReleasableAmount(beneficiary.address);
        expect(releasableAmount).to.equal(0);

        await vestingContract.connect(beneficiary).claim();
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(0);
    });

    it("Should allow claiming right after cliff ends", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVestingSchedule(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);

        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const cliffEndsTimestamp = Number(globalStartTime) + Number(schedule.cliffDuration);

        await helpers.time.increaseTo(cliffEndsTimestamp);

        await vestingContract.connect(beneficiary).claim();
        // After 1 minute (cliff), 1/10th of the tokens should be released.
        expect(await amdToken.balanceOf(beneficiary.address)).to.be.closeTo(scheduleAmount / 10n, ethers.parseUnits("1", "gwei"));
    });

    it("Should release tokens correctly over each installment", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVestingSchedule(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);

        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const cliffDuration = Number(schedule.cliffDuration);
        const releaseDuration = Number(schedule.releaseDuration);
        const installmentCount = Number(schedule.installmentCount);
        const installmentDuration = releaseDuration / installmentCount;

        for (let i = 1; i <= installmentCount; i++) {
            const timeToIncrease = Number(globalStartTime) + cliffDuration + (installmentDuration * (i - 1));
            await helpers.time.increaseTo(timeToIncrease);
            await vestingContract.connect(beneficiary).claim();

            const expectedAmount = (scheduleAmount * BigInt(i)) / BigInt(installmentCount);
            expect(await amdToken.balanceOf(beneficiary.address)).to.be.closeTo(expectedAmount, ethers.parseUnits("1", "gwei"));
        }
    });

    it("Should allow claiming all tokens after full vesting period", async function () {
        const { vestingContract, amdToken, owner, beneficiary, scheduleAmount } = await helpers.loadFixture(deployVestingFixture);

        const listingTimestamp = await helpers.time.latest();
        await vestingContract.connect(owner).createVestingSchedule(beneficiary.address, scheduleAmount);
        await vestingContract.connect(owner).setGlobalStartTime(listingTimestamp);

        const schedule = await vestingContract.vestingSchedules(beneficiary.address);
        const globalStartTime = await vestingContract.globalStartTime();
        const vestingEndsTimestamp = Number(globalStartTime) + Number(schedule.totalVestingDuration);

        await helpers.time.increaseTo(vestingEndsTimestamp);

        await vestingContract.connect(beneficiary).claim();
        expect(await amdToken.balanceOf(beneficiary.address)).to.equal(scheduleAmount);
    });
});
// ── ./test/constants.ts ──────────────────────────────────────────────
import { ethers } from "hardhat";

export const TOTAL_VESTING_AMOUNT_INVESTOR = ethers.parseUnits("24000000000", 18);
export const TOTAL_VESTING_AMOUNT_FOUNDER = ethers.parseUnits("20000000000", 18);
export const TOTAL_VESTING_AMOUNT_EMPLOYEE = ethers.parseUnits("5200000000", 18);

// ── ./test/utils/time.ts ──────────────────────────────────────────────
export function formatTimestamp(timestamp: number) {
    const date = new Date(timestamp * 1000);
    const Y = String(date.getUTCFullYear()).slice(-2);
    const M = String(date.getUTCMonth() + 1).padStart(2, '0');
    const D = String(date.getUTCDate()).padStart(2, '0');
    const h = String(date.getUTCHours()).padStart(2, '0');
    const m = String(date.getUTCMinutes()).padStart(2, '0');
    const s = String(date.getUTCSeconds()).padStart(2, '0');
    return `${Y}${M}${D}-${h}${m}${s}`;
}

export function formatAmdBalance(balance: BigInt): string {
    const divisor = BigInt(10)**BigInt(18);
    const result = balance;
    return result.toString();
}

export function formatAimBalance(balance: BigInt): string {
    const divisor = BigInt(10)**BigInt(8);
    const result = balance;
    return result.toString();
}
// ── ./tsconfig.json ──────────────────────────────────────────────
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  }
}
